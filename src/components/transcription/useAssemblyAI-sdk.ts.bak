import { useState, useRef, useCallback } from "react";
import { AssemblyAI } from "assemblyai";
import type { RealtimeTranscriber } from "assemblyai";
import type {
  TranscriptMessage,
  UseAssemblyAIOptions,
  UseAssemblyAIReturn,
} from "./types";

/**
 * AssemblyAI Realtime Transcription Hook
 *
 * MediaStreamã‹ã‚‰ã®éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’AssemblyAIã«ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã—ã¦ã€
 * ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§æ–‡å­—èµ·ã“ã—ã‚’è¡Œã†ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯
 */
export function useAssemblyAI(options: UseAssemblyAIOptions): UseAssemblyAIReturn {
  const { apiKey, sampleRate = 16000, formatTurns = true } = options;

  const [isConnected, setIsConnected] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [messages, setMessages] = useState<TranscriptMessage[]>([]);

  const transcriberRef = useRef<RealtimeTranscriber | null>(null);
  const audioContextRef = useRef<AudioContext | null>(null);
  const processorRef = useRef<ScriptProcessorNode | null>(null);
  const mediaStreamSourceRef = useRef<MediaStreamAudioSourceNode | null>(null);

  /**
   * AssemblyAIã«æ¥ç¶š
   */
  const connect = useCallback(async () => {
    if (isConnected || isConnecting) {
      console.warn("Already connected or connecting");
      return;
    }

    try {
      setIsConnecting(true);
      setError(null);

      console.log("ğŸ”§ Debug - apiKey:", apiKey ? "exists" : "missing");
      console.log("ğŸ”§ Debug - sampleRate:", sampleRate);
      console.log("ğŸ”§ Debug - formatTurns:", formatTurns);

      // AssemblyAI clientã‚’ä½œæˆ
      const client = new AssemblyAI({ apiKey });
      console.log("âœ… AssemblyAI client created");

      // transcriberã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æº–å‚™
      const transcriberParams = {
        sampleRate,
        encoding: "pcm_s16le" as const,
        disablePartialTranscripts: !formatTurns,
      };
      console.log("ğŸ”§ Debug - transcriberParams:", JSON.stringify(transcriberParams, null, 2));

      // transcriberã‚’ä½œæˆ
      const transcriber = client.realtime.transcriber(transcriberParams);
      console.log("âœ… Transcriber created");

      // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®è¨­å®š
      transcriber.on("open", ({ sessionId }) => {
        console.log(`AssemblyAI session opened: ${sessionId}`);
        setIsConnected(true);
        setIsConnecting(false);
      });

      transcriber.on("error", (err: Error) => {
        console.error("AssemblyAI error:", err);
        setError(err.message);
        setIsConnected(false);
        setIsConnecting(false);
      });

      transcriber.on("close", (code: number, reason: string) => {
        console.log(`AssemblyAI session closed: ${code} - ${reason}`);
        setIsConnected(false);
        setIsConnecting(false);
      });

      // æ–‡å­—èµ·ã“ã—çµæœã®å—ä¿¡
      transcriber.on("transcript", (transcript) => {
        if (!transcript.text) return;

        const newMessage: TranscriptMessage = {
          id: transcript.message_type === "FinalTranscript"
            ? `final-${Date.now()}`
            : `partial-${Date.now()}`,
          text: transcript.text,
          timestamp: Date.now(),
          isFinal: transcript.message_type === "FinalTranscript",
        };

        setMessages((prev) => {
          // éƒ¨åˆ†çš„ãªãƒˆãƒ©ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®å ´åˆã€æœ€å¾Œã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒéƒ¨åˆ†çš„ãªã‚‚ã®ãªã‚‰ç½®ãæ›ãˆã‚‹
          if (!newMessage.isFinal && prev.length > 0 && !prev[prev.length - 1].isFinal) {
            return [...prev.slice(0, -1), newMessage];
          }
          // ãã‚Œä»¥å¤–ã¯è¿½åŠ 
          return [...prev, newMessage];
        });
      });

      await transcriber.connect();
      transcriberRef.current = transcriber;
    } catch (err) {
      console.error("Failed to connect to AssemblyAI:", err);
      setError(err instanceof Error ? err.message : "Failed to connect");
      setIsConnecting(false);
    }
  }, [apiKey, sampleRate, formatTurns, isConnected, isConnecting]);

  /**
   * AssemblyAIã‹ã‚‰åˆ‡æ–­
   */
  const disconnect = useCallback(async () => {
    if (processorRef.current) {
      processorRef.current.disconnect();
      processorRef.current = null;
    }

    if (mediaStreamSourceRef.current) {
      mediaStreamSourceRef.current.disconnect();
      mediaStreamSourceRef.current = null;
    }

    if (audioContextRef.current) {
      await audioContextRef.current.close();
      audioContextRef.current = null;
    }

    if (transcriberRef.current) {
      await transcriberRef.current.close();
      transcriberRef.current = null;
    }

    setIsConnected(false);
  }, []);

  /**
   * éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’AssemblyAIã«é€ä¿¡
   */
  const sendAudioData = useCallback((audioData: Uint8Array) => {
    if (!transcriberRef.current || !isConnected) {
      console.warn("Transcriber not connected");
      return;
    }

    // Uint8Arrayã®bufferã‚’é€ä¿¡
    transcriberRef.current.sendAudio(audioData.buffer);
  }, [isConnected]);

  /**
   * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚¯ãƒªã‚¢
   */
  const clearMessages = useCallback(() => {
    setMessages([]);
  }, []);

  return {
    isConnected,
    isConnecting,
    error,
    messages,
    connect,
    disconnect,
    sendAudioData,
    clearMessages,
  };
}
